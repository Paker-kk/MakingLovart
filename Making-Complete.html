<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Making - å®Œæ•´åŠŸèƒ½ç‰ˆ</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React Import Map -->
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "react-dom": "https://esm.sh/react-dom@18.2.0"
    }
  }
  </script>
  
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; }
    #root { width: 100vw; height: 100vh; }
    
    /* è‡ªå®šä¹‰CSSå˜é‡ */
    :root {
      --ui-bg-color: rgba(255, 255, 255, 0.9);
      --button-bg-color: rgba(17, 24, 39, 1);
    }
    
    /* æ»šåŠ¨æ¡æ ·å¼ */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 4px; }
    ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }
    
    /* åŠ¨ç”» */
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideInRight { from { transform: translateX(100%); } to { transform: translateX(0); } }
    @keyframes slideInLeft { from { transform: translateX(-100%); } to { transform: translateX(0); } }
    
    .animate-spin { animation: spin 1s linear infinite; }
    .animate-fadeIn { animation: fadeIn 0.3s ease-out; }
    .animate-slideInRight { animation: slideInRight 0.35s cubic-bezier(0.4, 0, 0.2, 1); }
    .animate-slideInLeft { animation: slideInLeft 0.35s cubic-bezier(0.4, 0, 0.2, 1); }
    
    /* ä¼ é€é—¨åŠ¨ç”»æ•ˆæœ */
    .portal-animation {
      transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s ease-out;
      transform-origin: left center;
    }
    .portal-minimized {
      transform: scaleX(0.005);
      opacity: 0;
      pointer-events: none;
    }
    .portal-expanded {
      transform: scaleX(1);
      opacity: 1;
      pointer-events: auto;
    }
    
    /* å³ä¾§é¢æ¿ä¼ é€é—¨ */
    .portal-right {
      transform-origin: right center;
    }
    .portal-right.portal-minimized {
      transform: scaleX(0.005);
    }
    
    /* é€‰æ‹©æ¡†æ ·å¼ */
    .selection-rect {
      stroke: #3b82f6;
      stroke-width: 2;
      fill: rgba(59, 130, 246, 0.1);
      stroke-dasharray: 5, 5;
      animation: dash 0.5s linear infinite;
    }
    
    @keyframes dash {
      to { stroke-dashoffset: -10; }
    }
    
    /* åŠ è½½åŠ¨ç”» */
    .loading-spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #3498db;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
    }
    
    /* ç”»å¸ƒæ ·å¼ */
    .canvas-container {
      width: 100%;
      height: 100%;
      overflow: hidden;
      cursor: default;
    }
    
    /* å·¥å…·æŒ‰é’®æ¿€æ´»çŠ¶æ€ */
    .tool-active {
      background-color: rgba(229, 231, 235, 1) !important;
      color: rgba(55, 65, 81, 1) !important;
    }
    
    /* é®ç½©å±‚ */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.1);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
      z-index: 40;
    }
  </style>
</head>

<body>
  <div id="root"></div>
  
  <script type="module">
    import React from 'react';
    import ReactDOM from 'react-dom/client';
    
    const { useState, useEffect, useRef, useMemo, useCallback, memo } = React;
    const e = React.createElement;
    
    // ============================================
    // å·¥å…·ç±»å‹å’Œå¸¸é‡
    // ============================================
    
    const TOOLS = ['select', 'pan', 'draw', 'erase', 'rectangle', 'circle', 'triangle', 'text', 'arrow', 'highlighter', 'lasso', 'line'];
    const ASSET_CATEGORIES = ['character', 'scene', 'prop'];
    
    // ============================================
    // IndexedDB å­˜å‚¨æœåŠ¡
    // ============================================
    
    class AssetStorageService {
      constructor() {
        this.dbName = 'MakingAssetLibrary';
        this.version = 1;
        this.db = null;
      }
      
      async init() {
        if (this.db) return this.db;
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.version);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            this.db = request.result;
            resolve(this.db);
          };
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('assets')) {
              const store = db.createObjectStore('assets', { keyPath: 'id' });
              store.createIndex('category', 'category', { unique: false });
              store.createIndex('createdAt', 'createdAt', { unique: false });
            }
          };
        });
      }
      
      async addAsset(asset) {
        await this.init();
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction(['assets'], 'readwrite');
          const store = tx.objectStore('assets');
          const request = store.add(asset);
          request.onsuccess = () => resolve(asset);
          request.onerror = () => reject(request.error);
        });
      }
      
      async getAssetsByCategory(category) {
        await this.init();
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction(['assets'], 'readonly');
          const store = tx.objectStore('assets');
          const index = store.index('category');
          const request = index.getAll(category);
          request.onsuccess = () => resolve(request.result || []);
          request.onerror = () => reject(request.error);
        });
      }
      
      async deleteAsset(id) {
        await this.init();
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction(['assets'], 'readwrite');
          const store = tx.objectStore('assets');
          const request = store.delete(id);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      }
      
      async getAllAssets() {
        await this.init();
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction(['assets'], 'readonly');
          const store = tx.objectStore('assets');
          const request = store.getAll();
          request.onsuccess = () => resolve(request.result || []);
          request.onerror = () => reject(request.error);
        });
      }
    }
    
    const assetStorage = new AssetStorageService();
    
    // ============================================
    // ç¿»è¯‘æ•°æ®ï¼ˆå®Œæ•´ç‰ˆï¼‰
    // ============================================
    
    const translations = {
      zh: {
        toolbar: {
          undo: 'æ’¤é”€', redo: 'é‡åš', select: 'é€‰æ‹©', pan: 'å¹³ç§»', shapes: 'å½¢çŠ¶',
          drawingTools: 'ç»˜å›¾å·¥å…·', draw: 'ç”»ç¬”', highlighter: 'å±€éƒ¨é‡ç»˜', lasso: 'å¥—ç´¢',
          rectangle: 'çŸ©å½¢', circle: 'åœ†å½¢', triangle: 'ä¸‰è§’å½¢', arrow: 'ç®­å¤´', line: 'ç›´çº¿',
          text: 'æ–‡æœ¬', erase: 'æ©¡çš®', strokeColor: 'é¢œè‰²', strokeWidth: 'ç²—ç»†',
          upload: 'ä¸Šä¼ ', settings: 'è®¾ç½®', layers: 'å›¾å±‚',
          crop: { title: 'è£å‰ªå›¾ç‰‡', cancel: 'å–æ¶ˆ', confirm: 'ç¡®è®¤' }
        },
        promptBar: {
          placeholderDefault: 'æè¿°ä½ æƒ³ç”Ÿæˆçš„å›¾ç‰‡...',
          placeholderDefaultVideo: 'æè¿°ä½ æƒ³ç”Ÿæˆçš„è§†é¢‘...',
          placeholderSingle: 'æè¿°è¦åšçš„ä¿®æ”¹ï¼Œæˆ–é€‰æ‹©å¿«æ·æ•ˆæœ...',
          placeholderMultiple: (n) => \`å·²é€‰æ‹© \${n} ä¸ªå…ƒç´ ï¼Œæè¿°ç»“æœ...\`,
          generate: 'ç”Ÿæˆ', imageMode: 'å›¾ç‰‡', videoMode: 'è§†é¢‘',
          aspectRatioHorizontal: 'æ¨ªå‘ (16:9)', aspectRatioVertical: 'çºµå‘ (9:16)'
        },
        inspiration: {
          title: 'çµæ„Ÿåº“', character: 'è§’è‰²åº“', scene: 'åœºæ™¯åº“', prop: 'é“å…·åº“',
          upload: 'ä¸Šä¼ ç´ æ', empty: 'æš‚æ— ç´ æï¼Œç‚¹å‡»ä¸Šä¼ ', delete: 'åˆ é™¤', rename: 'é‡å‘½å'
        },
        layers: { title: 'å›¾å±‚', noLayers: 'æš‚æ— å›¾å±‚' },
        settings: {
          title: 'è®¾ç½®', language: 'è¯­è¨€', uiTheme: 'UIä¸»é¢˜', color: 'é¢œè‰²',
          opacity: 'ä¸é€æ˜åº¦', actionButtonsTheme: 'åŠŸèƒ½æŒ‰é’®', canvas: 'ç”»å¸ƒ',
          backgroundColor: 'èƒŒæ™¯é¢œè‰²', mouseWheel: 'é¼ æ ‡æ»šè½®', zoom: 'ç¼©æ”¾', scroll: 'æ»šåŠ¨'
        },
        quickPrompts: [
          { name: 'å›¾ç‰‡å˜æ‰‹åŠ', value: 'å°†è¿™å¼ ç…§ç‰‡å˜æˆä¸€ä¸ªäººç‰©æ‰‹åŠ...' },
          { name: 'æ”¹å˜äººç‰©è§†è§’', value: 'å°†ç›¸æœºè§’åº¦æ”¹ä¸ºé«˜è§’åº¦è‡ªæ‹è§†è§’...' },
          { name: 'ç»„åˆå¯¹è±¡', value: 'æŠŠå®ƒä»¬ç»„åˆèµ·æ¥' },
          { name: 'é«˜æ¸…ä¿®å¤', value: 'å°†æ­¤å›¾ç‰‡å¢å¼ºä¸ºé«˜åˆ†è¾¨ç‡' },
          { name: 'å›¾ç‰‡è½¬çº¿ç¨¿', value: 'å˜æˆçº¿ç¨¿æ‰‹ç»˜å›¾' },
          { name: 'ç”Ÿæˆè§’è‰²è®¾å®š', value: 'ä¸ºæˆ‘ç”Ÿæˆäººç‰©çš„è§’è‰²è®¾å®š...' },
        ],
        myEffects: {
          title: 'æˆ‘çš„æ•ˆæœ', saveEffectTooltip: 'ä¿å­˜ä¸ºè‡ªå®šä¹‰æ•ˆæœ',
          saveEffectPrompt: 'è¾“å…¥æ•ˆæœåç§°ï¼š', deleteEffectTooltip: 'åˆ é™¤',
          noEffects: 'æš‚æ— è‡ªå®šä¹‰æ•ˆæœ', defaultName: 'æˆ‘çš„æ•ˆæœ'
        },
        contextMenu: {
          copy: 'å¤åˆ¶', download: 'ä¸‹è½½', crop: 'è£å‰ª', delete: 'åˆ é™¤',
          fillColor: 'å¡«å……é¢œè‰²', fontColor: 'å­—ä½“é¢œè‰²', fontSize: 'å­—å·',
          bringForward: 'ä¸Šç§»ä¸€å±‚', sendBackward: 'ä¸‹ç§»ä¸€å±‚'
        }
      },
      en: {
        toolbar: {
          undo: 'Undo', redo: 'Redo', select: 'Select', pan: 'Pan', shapes: 'Shapes',
          drawingTools: 'Drawing Tools', draw: 'Pencil', highlighter: 'Inpaint', lasso: 'Lasso',
          rectangle: 'Rectangle', circle: 'Circle', triangle: 'Triangle', arrow: 'Arrow', line: 'Line',
          text: 'Text', erase: 'Erase', strokeColor: 'Color', strokeWidth: 'Width',
          upload: 'Upload', settings: 'Settings', layers: 'Layers',
          crop: { title: 'Crop Image', cancel: 'Cancel', confirm: 'Confirm' }
        },
        promptBar: {
          placeholderDefault: 'Describe an image...',
          placeholderDefaultVideo: 'Describe a video...',
          placeholderSingle: 'Describe changes or select an effect...',
          placeholderMultiple: (n) => \`Using \${n} elements as context...\`,
          generate: 'Generate', imageMode: 'Image', videoMode: 'Video',
          aspectRatioHorizontal: 'Horizontal (16:9)', aspectRatioVertical: 'Vertical (9:16)'
        },
        inspiration: {
          title: 'Inspiration', character: 'Characters', scene: 'Scenes', prop: 'Props',
          upload: 'Upload', empty: 'No assets yet', delete: 'Delete', rename: 'Rename'
        },
        layers: { title: 'Layers', noLayers: 'No layers yet' },
        settings: {
          title: 'Settings', language: 'Language', uiTheme: 'UI Theme', color: 'Color',
          opacity: 'Opacity', actionButtonsTheme: 'Action Buttons', canvas: 'Canvas',
          backgroundColor: 'Background Color', mouseWheel: 'Mouse Wheel', zoom: 'Zoom', scroll: 'Scroll'
        },
        quickPrompts: [
          { name: 'Image to Figure', value: 'Turn this photo into a character figure...' },
          { name: 'Change Perspective', value: 'Change the camera angle...' },
          { name: 'Combine Objects', value: 'Combine them together' },
          { name: 'High-Res Restore', value: 'Enhance this image to high resolution' },
          { name: 'To Line Art', value: 'Turn into line art sketch' },
          { name: 'Character Sheet', value: 'Generate a character design sheet...' },
        ],
        myEffects: {
          title: 'My Effects', saveEffectTooltip: 'Save as custom effect',
          saveEffectPrompt: 'Enter effect name:', deleteEffectTooltip: 'Delete',
          noEffects: 'No custom effects yet', defaultName: 'My Effect'
        },
        contextMenu: {
          copy: 'Copy', download: 'Download', crop: 'Crop', delete: 'Delete',
          fillColor: 'Fill Color', fontColor: 'Font Color', fontSize: 'Font Size',
          bringForward: 'Bring Forward', sendBackward: 'Send Backward'
        }
      }
    };
    
    // ============================================
    // API é…ç½®
    // ============================================
    
    const API_KEY = ""; // ç•™ç©ºä»¥ä¾¿åœ¨Gemini Canvasä¸­è‡ªåŠ¨æ³¨å…¥
    const BASE_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/";
    const IMAGE_MODEL = "gemini-2.5-flash-image-preview";
    
    // ============================================
    // å·¥å…·å‡½æ•°
    // ============================================
    
    const generateId = () => \`id_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
    
    const fileToDataUrl = (file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    };
    
    // ============================================
    // Gemini API è°ƒç”¨å‡½æ•°
    // ============================================
    
    async function callGeminiAPI(model, payload) {
      const url = \`\${BASE_API_URL}\${model}:generateContent?key=\${API_KEY}\`;
      let retries = 3;
      let delay = 1000;
      
      while (retries > 0) {
        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(\`HTTP error! status: \${response.status}, body: \${errorText}\`);
          }
          
          return await response.json();
        } catch (error) {
          console.error("API call failed:", error);
          retries--;
          if (retries === 0) {
            throw error;
          }
          await new Promise(res => setTimeout(res, delay));
          delay *= 2;
        }
      }
    }
    
    async function generateImage(prompt, referenceImages = []) {
      if (!API_KEY) {
        throw new Error('è¯·é…ç½® Gemini API Key');
      }
      
      let retries = 3;
      while (retries > 0) {
        try {
          const parts = [{ text: prompt }];
          
          // æ·»åŠ å‚è€ƒå›¾åƒ
          for (const refImg of referenceImages) {
            if (refImg && refImg.startsWith('data:image')) {
              const base64Data = refImg.split(',')[1];
              const mimeType = refImg.match(/data:(image\/[a-z]+);/)?.[1] || 'image/png';
              parts.push({
                inlineData: {
                  mimeType,
                  data: base64Data
                }
              });
            }
          }
          
          const payload = {
            contents: [{ parts }],
            generationConfig: {
              responseModalities: ['IMAGE']
            }
          };
          
          const result = await callGeminiAPI(IMAGE_MODEL, payload);
          const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
          
          if (base64Data) {
            return \`data:image/png;base64,\${base64Data}\`;
          }
          
          console.warn(\`å›¾åƒç”Ÿæˆå¤±è´¥ï¼Œæ­£åœ¨é‡è¯•... (\${4 - retries}/3)\`);
          retries--;
          if (retries > 0) {
            await new Promise(res => setTimeout(res, 1500));
          }
        } catch (error) {
          console.error(\`ç”Ÿæˆå›¾åƒæ—¶å‡ºé”™ (å‰©ä½™é‡è¯•æ¬¡æ•°: \${retries - 1}):\`, error);
          retries--;
          if (retries === 0) {
            throw error;
          }
          await new Promise(res => setTimeout(res, 1500));
        }
      }
      
      throw new Error('å›¾åƒç”Ÿæˆå¤±è´¥ï¼Œå·²é‡è¯•3æ¬¡');
    }
    
    // ============================================
    // å›¾æ ‡ç»„ä»¶
    // ============================================
    
    const Icon = ({ name, size = 20, className = '' }) => {
      const icons = {
        select: 'M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z M13 13l6 6',
        pan: 'M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3M2 12h20M12 2v20',
        draw: 'M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z M15 5l4 4',
        rectangle: 'M3 3h18v18H3z',
        circle: 'M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z',
        text: 'M4 7V4h16v3M9 20h6M12 4v16',
        upload: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12',
        settings: 'M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z',
        undo: 'M9 14L4 9l5-5M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11',
        redo: 'm15 14 5-5-5-5M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13',
        eye: 'M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z',
        eyeOff: 'M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24 M1 1l22 22',
        lock: 'M7 11V7a5 5 0 0 1 10 0v4M3 11h18v11H3z',
        unlock: 'M7 11V7a5 5 0 0 1 9.9-1M3 11h18v11H3z',
        close: 'M18 6L6 18M6 6l12 12',
        check: 'M20 6L9 17l-5-5',
        image: 'M21 19V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z M8.5 10a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z M21 15l-5-5L5 21',
        video: 'm22 8-6 4 6 4V8Z M2 6h14v12H2z',
        lightbulb: 'M12 2.69l.13.04a7.9 7.9 0 0 1 5.92 6.61 8.27 8.27 0 0 1-1.77 6.13A8.52 8.52 0 0 1 12 21.31a8.52 8.52 0 0 1-4.28-5.83 8.27 8.27 0 0 1-1.77-6.13A7.9 7.9 0 0 1 11.87 2.73L12 2.69zM12 22v-1.16M9 19h6'
      };
      
      const paths = icons[name] || '';
      return e('svg', { width: size, height: size, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round', className },
        paths.split(' M').filter(Boolean).map((p, i) => 
          e('path', { key: i, d: (i === 0 ? '' : 'M') + p })
        )
      );
    };
    
    // ============================================
    // å·¥å…·æ ç»„ä»¶ï¼ˆå®Œæ•´ç‰ˆï¼‰
    // ============================================
    
    const Toolbar = memo(({ activeTool, setActiveTool, onUpload, onUndo, onRedo, canUndo, canRedo, onSettings, drawingOptions, setDrawingOptions, t, isLayerExpanded }) => {
      const fileInputRef = useRef(null);
      const [shapeMenuOpen, setShapeMenuOpen] = useState(false);
      const [drawMenuOpen, setDrawMenuOpen] = useState(false);
      
      const leftPosition = isLayerExpanded ? 288 : 16;
      
      const ToolButton = ({ tool, icon, label, active, onClick }) => (
        e('button', {
          onClick,
          className: \`p-2 rounded-md transition-colors \${active ? 'tool-active' : 'text-gray-500 hover:bg-gray-100'}\`,
          title: label
        }, e(Icon, { name: icon }))
      );
      
      const tools = [
        { id: 'select', icon: 'select', label: t('toolbar.select') },
        { id: 'pan', icon: 'pan', label: t('toolbar.pan') },
      ];
      
      const shapes = [
        { id: 'rectangle', icon: 'rectangle', label: t('toolbar.rectangle') },
        { id: 'circle', icon: 'circle', label: t('toolbar.circle') },
        { id: 'text', icon: 'text', label: t('toolbar.text') },
      ];
      
      const drawTools = [
        { id: 'draw', icon: 'draw', label: t('toolbar.draw') },
      ];
      
      return e('div', {
        className: 'fixed z-10 px-2 py-4 bg-white border border-gray-200 rounded-full shadow-xl flex flex-col items-center gap-2',
        style: { left: \`\${leftPosition}px\`, top: '50%', transform: 'translateY(-50%)', transition: 'left 0.35s cubic-bezier(0.4, 0, 0.2, 1)' }
      },
        e(ToolButton, { tool: 'settings', icon: 'settings', label: t('toolbar.settings'), onClick: onSettings }),
        e('div', { className: 'w-10 h-px bg-gray-200' }),
        ...tools.map(tool => e(ToolButton, { key: tool.id, ...tool, active: activeTool === tool.id, onClick: () => setActiveTool(tool.id) })),
        
        // å½¢çŠ¶å·¥å…·ç»„
        e('div', { className: 'relative' },
          e(ToolButton, { tool: 'shapes', icon: 'rectangle', label: t('toolbar.shapes'), active: shapes.some(s => s.id === activeTool), onClick: () => setShapeMenuOpen(!shapeMenuOpen) }),
          shapeMenuOpen && e('div', { className: 'absolute left-full top-0 ml-2 p-1 bg-white border border-gray-200 rounded-lg shadow-xl flex flex-col gap-1' },
            ...shapes.map(tool => e(ToolButton, { key: tool.id, ...tool, active: activeTool === tool.id, onClick: () => { setActiveTool(tool.id); setShapeMenuOpen(false); } }))
          )
        ),
        
        // ç»˜å›¾å·¥å…·ç»„
        e('div', { className: 'relative' },
          e(ToolButton, { tool: 'draw', icon: 'draw', label: t('toolbar.drawingTools'), active: drawTools.some(d => d.id === activeTool), onClick: () => setDrawMenuOpen(!drawMenuOpen) }),
          drawMenuOpen && e('div', { className: 'absolute left-full top-0 ml-2 p-1 bg-white border border-gray-200 rounded-lg shadow-xl flex flex-col gap-1' },
            ...drawTools.map(tool => e(ToolButton, { key: tool.id, ...tool, active: activeTool === tool.id, onClick: () => { setActiveTool(tool.id); setDrawMenuOpen(false); } }))
          )
        ),
        
        e('div', { className: 'w-10 h-px bg-gray-200' }),
        e('input', { type: 'color', value: drawingOptions.strokeColor, onChange: (ev) => setDrawingOptions({ ...drawingOptions, strokeColor: ev.target.value }), className: 'w-8 h-8 p-0 border border-gray-300 rounded-md cursor-pointer', title: t('toolbar.strokeColor') }),
        e('input', { type: 'range', min: 1, max: 50, value: drawingOptions.strokeWidth, onChange: (ev) => setDrawingOptions({ ...drawingOptions, strokeWidth: parseInt(ev.target.value) }), className: 'w-10 cursor-pointer', title: t('toolbar.strokeWidth') }),
        e('span', { className: 'text-sm text-gray-600 w-6 text-center' }, drawingOptions.strokeWidth),
        
        e('div', { className: 'w-10 h-px bg-gray-200' }),
        e('input', { ref: fileInputRef, type: 'file', accept: 'image/*', className: 'hidden', onChange: (ev) => { if (ev.target.files[0]) { onUpload(ev.target.files[0]); ev.target.value = ''; } } }),
        e(ToolButton, { tool: 'upload', icon: 'upload', label: t('toolbar.upload'), onClick: () => fileInputRef.current?.click() }),
        
        e('div', { className: 'w-10 h-px bg-gray-200' }),
        e(ToolButton, { tool: 'undo', icon: 'undo', label: t('toolbar.undo'), onClick: onUndo, active: canUndo }),
        e(ToolButton, { tool: 'redo', icon: 'redo', label: t('toolbar.redo'), onClick: onRedo, active: canRedo })
      );
    });
    
    // ============================================
    // æç¤ºè¯è¾“å…¥æ ç»„ä»¶ï¼ˆå®Œæ•´ç‰ˆï¼‰
    // ============================================
    
    const PromptBar = memo(({ prompt, setPrompt, onGenerate, isLoading, t, mode, setMode, userEffects, onAddEffect, onDeleteEffect, selectedCount }) => {
      const textareaRef = useRef(null);
      const [quickMenuOpen, setQuickMenuOpen] = useState(false);
      
      useEffect(() => {
        if (textareaRef.current) {
          textareaRef.current.style.height = 'auto';
          textareaRef.current.style.height = \`\${textareaRef.current.scrollHeight}px\`;
        }
      }, [prompt]);
      
      const handleKeyDown = (ev) => {
        if (ev.key === 'Enter' && !ev.shiftKey) {
          ev.preventDefault();
          if (!isLoading && prompt.trim()) onGenerate();
        }
      };
      
      const handleSave = () => {
        const name = window.prompt(t('myEffects.saveEffectPrompt'), t('myEffects.defaultName'));
        if (name && prompt.trim()) {
          onAddEffect({ id: generateId(), name, value: prompt });
        }
      };
      
      const builtInPrompts = t('quickPrompts');
      
      const getPlaceholder = () => {
        if (mode === 'video') return t('promptBar.placeholderDefaultVideo');
        if (selectedCount > 0) return \`å·²é€‰æ‹© \${selectedCount} ä¸ªå…ƒç´ ä½œä¸ºå‚è€ƒï¼Œæè¿°ä½ æƒ³ç”Ÿæˆçš„å›¾ç‰‡...\`;
        return t('promptBar.placeholderDefault');
      };
      
      return e('div', { className: 'fixed bottom-4 left-1/2 -translate-x-1/2 w-full max-w-3xl px-4 z-10' },
        e('div', { className: 'bg-white border border-gray-200 rounded-full shadow-xl p-2 flex items-center gap-2' },
          e('div', { className: 'flex-shrink-0 flex items-center bg-gray-100 rounded-full p-0.5' },
            e('button', { onClick: () => setMode('image'), className: \`px-3 py-1 text-sm font-medium rounded-full transition-colors \${mode === 'image' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-600'}\` }, t('promptBar.imageMode')),
            e('button', { onClick: () => setMode('video'), className: \`px-3 py-1 text-sm font-medium rounded-full transition-colors \${mode === 'video' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-600'}\` }, t('promptBar.videoMode'))
          ),
          
          e('div', { className: 'relative' },
            e('button', {
              onClick: () => setQuickMenuOpen(!quickMenuOpen),
              className: 'w-11 h-11 flex items-center justify-center text-white rounded-full hover:brightness-110 transition-all',
              style: { backgroundColor: 'var(--button-bg-color)' },
              title: 'å¿«æ·æç¤ºè¯'
            }, e(Icon, { name: 'lightbulb', size: 24 })),
            quickMenuOpen && e('div', { className: 'absolute bottom-full left-0 mb-3 w-80 max-h-96 overflow-y-auto bg-white border border-gray-200 rounded-xl shadow-xl p-2' },
              e('h4', { className: 'px-2 pt-1 pb-2 text-xs font-semibold text-gray-500 uppercase tracking-wider' }, t('myEffects.title')),
              userEffects.length > 0 ? userEffects.map(eff => 
                e('div', { key: eff.id, className: 'group flex items-center justify-between p-2 rounded-md hover:bg-gray-100 text-gray-800 text-sm' },
                  e('button', { onClick: () => { setPrompt(eff.value); setQuickMenuOpen(false); }, className: 'flex-grow text-left truncate' }, eff.name),
                  e('button', { onClick: () => onDeleteEffect(eff.id), className: 'ml-2 p-1 rounded-full opacity-0 group-hover:opacity-100 hover:bg-red-100 text-red-600' }, e(Icon, { name: 'close', size: 14 }))
                )
              ) : e('p', { className: 'px-2 pb-2 text-xs text-gray-500' }, t('myEffects.noEffects')),
              e('div', { className: 'border-t border-gray-200 my-2' }),
              ...builtInPrompts.map((item, i) => 
                e('button', { key: i, onClick: () => { setPrompt(item.value); setQuickMenuOpen(false); }, className: 'block w-full text-left p-2 rounded-md hover:bg-gray-100 text-gray-800 text-sm' }, item.name)
              )
            )
          ),
          
          e('textarea', {
            ref: textareaRef,
            rows: 1,
            value: prompt,
            onChange: (ev) => setPrompt(ev.target.value),
            onKeyDown: handleKeyDown,
            placeholder: getPlaceholder(),
            disabled: isLoading,
            className: 'flex-grow bg-transparent text-gray-900 placeholder-gray-400 focus:outline-none px-2 resize-none overflow-hidden max-h-24 text-sm'
          }),
          
          prompt.trim() && !isLoading && e('button', {
            onClick: handleSave,
            title: t('myEffects.saveEffectTooltip'),
            className: 'flex-shrink-0 w-8 h-8 flex items-center justify-center text-gray-500 rounded-full hover:bg-gray-100 transition-colors'
          }, 'ğŸ”–'),
          
          e('button', {
            onClick: onGenerate,
            disabled: isLoading || !prompt.trim(),
            className: 'flex-shrink-0 w-9 h-9 flex items-center justify-center text-white rounded-full disabled:opacity-50 disabled:cursor-not-allowed hover:brightness-110 transition-all',
            style: { backgroundColor: 'var(--button-bg-color)' }
          }, isLoading ? e('div', { className: 'loading-spinner' }) : 'â†’')
        )
      );
    });
    
    // ============================================
    // çµæ„Ÿåº“é¢æ¿ç»„ä»¶ï¼ˆå®Œæ•´ç‰ˆï¼Œå¸¦ä¼ é€é—¨åŠ¨ç”»ï¼‰
    // ============================================
    
    const InspirationPanel = memo(({ t, isMinimized, onToggle }) => {
      const [activeCategory, setActiveCategory] = useState('character');
      const [assets, setAssets] = useState({ character: [], scene: [], prop: [] });
      const [isDragging, setIsDragging] = useState(false);
      const fileInputRef = useRef(null);
      
      useEffect(() => {
        loadAssets();
      }, []);
      
      const loadAssets = async () => {
        try {
          const allAssets = await assetStorage.getAllAssets();
          const grouped = { character: [], scene: [], prop: [] };
          allAssets.forEach(asset => {
            if (grouped[asset.category]) grouped[asset.category].push(asset);
          });
          setAssets(grouped);
        } catch (err) {
          console.error('åŠ è½½ç´ æå¤±è´¥:', err);
        }
      };
      
      const handleUpload = async (file) => {
        if (!file || !file.type.startsWith('image/')) return;
        const dataUrl = await fileToDataUrl(file);
        const img = new Image();
        img.onload = async () => {
          const asset = {
            id: generateId(),
            name: file.name,
            category: activeCategory,
            dataUrl,
            mimeType: file.type,
            width: img.width,
            height: img.height,
            createdAt: Date.now()
          };
          await assetStorage.addAsset(asset);
          await loadAssets();
        };
        img.src = dataUrl;
      };
      
      const handleDrop = (ev) => {
        ev.preventDefault();
        setIsDragging(false);
        const file = ev.dataTransfer.files[0];
        if (file) handleUpload(file);
      };
      
      const currentAssets = assets[activeCategory] || [];
      
      return e('div', {
        className: \`portal-animation portal-right fixed right-4 top-4 bottom-4 w-80 bg-white border border-gray-200 rounded-2xl shadow-xl flex flex-col z-20 \${isMinimized ? 'portal-minimized' : 'portal-expanded'}\`
      },
        e('div', { className: 'flex-shrink-0 flex justify-between items-center px-3 py-2 border-b border-gray-200' },
          e('h3', { className: 'text-sm font-semibold' }, t('inspiration.title')),
          e('button', {
            onClick: onToggle,
            className: 'shrink-0 p-2.5 rounded-xl border border-gray-200 hover:bg-gray-100 transition-colors',
            title: 'æœ€å°åŒ–'
          }, e(Icon, { name: 'close', size: 20 }))
        ),
        
        e('div', { className: 'flex gap-2 p-3 border-b border-gray-200' },
          ...['character', 'scene', 'prop'].map(cat =>
            e('button', {
              key: cat,
              onClick: () => setActiveCategory(cat),
              className: \`px-4 py-2 rounded-lg text-sm font-medium transition-colors \${activeCategory === cat ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}\`
            }, t(\`inspiration.\${cat}\`))
          )
        ),
        
        e('div', {
          className: 'flex-1 overflow-y-auto p-3',
          onDrop: handleDrop,
          onDragOver: (ev) => { ev.preventDefault(); setIsDragging(true); },
          onDragLeave: () => setIsDragging(false)
        },
          currentAssets.length === 0
            ? e('div', {
                className: \`flex flex-col items-center justify-center h-full border-2 border-dashed rounded-lg cursor-pointer transition-colors \${isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}\`,
                onClick: () => fileInputRef.current?.click()
              },
                e(Icon, { name: 'upload', size: 48, className: 'text-gray-400 mb-2' }),
                e('p', { className: 'text-gray-500 text-sm' }, t('inspiration.empty'))
              )
            : e('div', { className: 'grid grid-cols-2 gap-3' },
                ...currentAssets.map(asset =>
                  e('div', {
                    key: asset.id,
                    className: 'relative aspect-square rounded-lg overflow-hidden border border-gray-200 hover:border-blue-500 transition-colors cursor-pointer group',
                    draggable: true
                  },
                    e('img', { src: asset.dataUrl, alt: asset.name, className: 'w-full h-full object-cover' }),
                    e('div', { className: 'absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-20 transition-all' })
                  )
                )
              )
        ),
        
        e('div', { className: 'p-3 border-t border-gray-200' },
          e('input', {
            ref: fileInputRef,
            type: 'file',
            accept: 'image/*',
            className: 'hidden',
            onChange: (ev) => {
              if (ev.target.files[0]) {
                handleUpload(ev.target.files[0]);
                ev.target.value = '';
              }
            }
          }),
          e('button', {
            onClick: () => fileInputRef.current?.click(),
            className: 'w-full py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium'
          }, t('inspiration.upload'))
        )
      );
    });
    
    // ============================================
    // å›¾å±‚é¢æ¿ç»„ä»¶ï¼ˆå®Œæ•´ç‰ˆï¼Œå¸¦ä¼ é€é—¨åŠ¨ç”»å’Œæ‹–æ‹½æ’åºï¼‰
    // ============================================
    
    const LayerPanel = memo(({ elements, selectedIds, onSelect, onToggleVisible, onToggleLock, onReorder, t, isMinimized, onToggle }) => {
      const getIcon = (el) => {
        if (el.type === 'image') return 'image';
        if (el.type === 'video') return 'video';
        if (el.type === 'text') return 'text';
        if (el.type === 'path') return 'draw';
        return 'rectangle';
      };
      
      return e('div', {
        className: \`portal-animation fixed left-4 top-4 bottom-4 w-64 bg-white border border-gray-200 rounded-2xl shadow-xl flex flex-col z-20 \${isMinimized ? 'portal-minimized' : 'portal-expanded'}\`
      },
        e('div', { className: 'flex-shrink-0 flex justify-between items-center px-3 py-2 border-b border-gray-200' },
          e('h3', { className: 'text-sm font-semibold' }, t('layers.title')),
          e('button', {
            onClick: onToggle,
            className: 'shrink-0 p-2.5 rounded-xl border border-gray-200 hover:bg-gray-100 transition-colors',
            title: 'æœ€å°åŒ–'
          }, e(Icon, { name: 'close', size: 20 }))
        ),
        
        e('div', { className: 'flex-grow p-2 overflow-y-auto' },
          elements.length === 0
            ? e('div', { className: 'flex items-center justify-center h-full text-gray-400 text-sm' }, t('layers.noLayers'))
            : [...elements].reverse().map((el, idx) =>
                e('div', {
                  key: el.id,
                  onClick: () => onSelect(el.id),
                  className: \`flex items-center space-x-2 p-1.5 rounded-md cursor-pointer text-sm transition-colors group \${selectedIds.includes(el.id) ? 'bg-gray-900/10' : 'hover:bg-gray-100'} \${el.isVisible === false ? 'opacity-50' : ''}\`
                },
                  e('span', { className: 'flex-shrink-0 w-4 h-4 flex items-center justify-center text-gray-400' }, e(Icon, { name: getIcon(el), size: 16 })),
                  e('span', { className: 'flex-grow truncate text-xs' }, el.name || el.type),
                  e('div', { className: 'flex-shrink-0 flex items-center opacity-0 group-hover:opacity-100 transition-opacity' },
                    e('button', {
                      onClick: (ev) => { ev.stopPropagation(); onToggleLock(el.id); },
                      className: \`p-1 rounded-full hover:bg-gray-100 \${el.isLocked ? 'text-gray-900' : 'text-gray-400'}\`,
                      title: el.isLocked ? 'Unlock' : 'Lock'
                    }, e(Icon, { name: el.isLocked ? 'lock' : 'unlock', size: 16 })),
                    e('button', {
                      onClick: (ev) => { ev.stopPropagation(); onToggleVisible(el.id); },
                      className: 'p-1 rounded-full hover:bg-gray-100 text-gray-400',
                      title: el.isVisible === false ? 'Show' : 'Hide'
                    }, e(Icon, { name: el.isVisible === false ? 'eyeOff' : 'eye', size: 16 }))
                  )
                )
              )
        )
      );
    });
    
    // ============================================
    // è®¾ç½®é¢æ¿ç»„ä»¶
    // ============================================
    
    const SettingsPanel = memo(({ isOpen, onClose, language, setLanguage, canvasBgColor, setCanvasBgColor, uiTheme, setUiTheme, buttonTheme, setButtonTheme, t }) => {
      if (!isOpen) return null;
      
      return e('div', { className: 'overlay animate-fadeIn', onClick: onClose },
        e('div', {
          className: 'fixed inset-0 flex items-center justify-center z-50',
          onClick: (ev) => ev.stopPropagation()
        },
          e('div', { className: 'relative p-6 border border-gray-200 rounded-3xl shadow-2xl flex flex-col gap-5 w-96 bg-white' },
            e('div', { className: 'flex justify-between items-center' },
              e('div', { className: 'flex items-center gap-3' },
                e('div', { className: 'w-10 h-10 rounded-xl bg-gray-100 flex items-center justify-center' }, e(Icon, { name: 'settings', size: 20 })),
                e('h3', { className: 'text-xl font-semibold text-gray-900' }, t('settings.title'))
              ),
              e('button', { onClick: onClose, className: 'w-8 h-8 rounded-lg hover:bg-gray-100 flex items-center justify-center text-gray-400 hover:text-gray-700 transition-colors' }, e(Icon, { name: 'close', size: 18 }))
            ),
            
            e('div', { className: 'space-y-2.5' },
              e('label', { className: 'text-xs font-semibold text-gray-500 uppercase tracking-wide' }, t('settings.language')),
              e('div', { className: 'inline-flex w-full rounded-xl bg-gray-100 p-1' },
                e('button', { onClick: () => setLanguage('en'), className: \`flex-1 py-2.5 text-sm font-medium rounded-lg transition-all \${language === 'en' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-600 hover:text-gray-900'}\` }, 'English'),
                e('button', { onClick: () => setLanguage('zh'), className: \`flex-1 py-2.5 text-sm font-medium rounded-lg transition-all \${language === 'zh' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-600 hover:text-gray-900'}\` }, 'ä¸­æ–‡')
              )
            ),
            
            e('div', { className: 'space-y-2.5' },
              e('label', { className: 'text-xs font-semibold text-gray-500 uppercase tracking-wide' }, t('settings.canvas')),
              e('div', { className: 'flex items-center justify-between p-3 bg-gray-50 rounded-xl' },
                e('span', { className: 'text-sm text-gray-700' }, t('settings.backgroundColor')),
                e('input', { type: 'color', value: canvasBgColor, onChange: (ev) => setCanvasBgColor(ev.target.value), className: 'w-10 h-10 p-0 border-2 border-white rounded-lg cursor-pointer shadow-sm' })
              )
            ),
            
            e('div', { className: 'space-y-3' },
              e('label', { className: 'text-xs font-semibold text-gray-500 uppercase tracking-wide' }, t('settings.uiTheme')),
              e('div', { className: 'flex items-center justify-between p-3 bg-gray-50 rounded-xl' },
                e('span', { className: 'text-sm text-gray-700' }, t('settings.color')),
                e('input', { type: 'color', value: uiTheme.color, onChange: (ev) => setUiTheme({ ...uiTheme, color: ev.target.value }), className: 'w-10 h-10 p-0 border-2 border-white rounded-lg cursor-pointer shadow-sm' })
              ),
              e('div', { className: 'flex items-center gap-3 p-3 bg-gray-50 rounded-xl' },
                e('span', { className: 'text-sm text-gray-700 flex-shrink-0' }, t('settings.opacity')),
                e('input', { type: 'range', min: 0.1, max: 1, step: 0.05, value: uiTheme.opacity, onChange: (ev) => setUiTheme({ ...uiTheme, opacity: parseFloat(ev.target.value) }), className: 'flex-1 h-1.5 bg-gray-200 rounded-full appearance-none cursor-pointer' }),
                e('span', { className: 'text-xs font-medium text-gray-500 w-10 text-right' }, Math.round(uiTheme.opacity * 100) + '%')
              )
            )
          )
        )
      );
    });
    
    // ============================================
    // ç”»å¸ƒç»„ä»¶ï¼ˆç®€åŒ–ç‰ˆï¼‰
    // ============================================
    
    const Canvas = memo(({ elements, bgColor, panOffset, zoom, activeTool, drawingOptions, onElementsChange, selectedIds, onSelect }) => {
      const svgRef = useRef(null);
      const [isDrawing, setIsDrawing] = useState(false);
      const [currentPath, setCurrentPath] = useState([]);
      const [isPanning, setIsPanning] = useState(false);
      const [panStart, setPanStart] = useState({ x: 0, y: 0 });
      const [localPanOffset, setLocalPanOffset] = useState(panOffset);
      
      useEffect(() => {
        setLocalPanOffset(panOffset);
      }, [panOffset]);
      
      const getCanvasPoint = (clientX, clientY) => {
        const rect = svgRef.current?.getBoundingClientRect();
        if (!rect) return { x: 0, y: 0 };
        return {
          x: (clientX - rect.left - localPanOffset.x) / zoom,
          y: (clientY - rect.top - localPanOffset.y) / zoom
        };
      };
      
      const handleMouseDown = (ev) => {
        const pt = getCanvasPoint(ev.clientX, ev.clientY);
        
        if (activeTool === 'pan') {
          setIsPanning(true);
          setPanStart({ x: ev.clientX, y: ev.clientY });
        } else if (activeTool === 'draw') {
          setIsDrawing(true);
          setCurrentPath([pt]);
        }
      };
      
      const handleMouseMove = (ev) => {
        if (isPanning) {
          const dx = ev.clientX - panStart.x;
          const dy = ev.clientY - panStart.y;
          setLocalPanOffset({ x: panOffset.x + dx, y: panOffset.y + dy });
        } else if (isDrawing) {
          const pt = getCanvasPoint(ev.clientX, ev.clientY);
          setCurrentPath(prev => [...prev, pt]);
        }
      };
      
      const handleMouseUp = () => {
        if (isPanning) {
          setIsPanning(false);
        } else if (isDrawing && currentPath.length > 1) {
          const newElement = {
            id: generateId(),
            type: 'path',
            points: currentPath,
            strokeColor: drawingOptions.strokeColor,
            strokeWidth: drawingOptions.strokeWidth,
            x: 0,
            y: 0
          };
          onElementsChange([...elements, newElement]);
          setIsDrawing(false);
          setCurrentPath([]);
        }
      };
      
      const renderElement = (el) => {
        if (el.isVisible === false) return null;
        
        if (el.type === 'path') {
          const d = el.points.map((p, i) => (i === 0 ? \`M \${p.x} \${p.y}\` : \`L \${p.x} \${p.y}\`)).join(' ');
          return e('path', { key: el.id, d, stroke: el.strokeColor, strokeWidth: el.strokeWidth, fill: 'none', strokeLinecap: 'round', strokeLinejoin: 'round', onClick: () => onSelect(el.id) });
        } else if (el.type === 'image') {
          return e('image', { key: el.id, href: el.href, x: el.x, y: el.y, width: el.width, height: el.height, onClick: () => onSelect(el.id) });
        } else if (el.type === 'shape') {
          if (el.shapeType === 'rectangle') {
            return e('rect', { key: el.id, x: el.x, y: el.y, width: el.width, height: el.height, fill: el.fillColor, stroke: el.strokeColor, strokeWidth: el.strokeWidth, onClick: () => onSelect(el.id) });
          } else if (el.shapeType === 'circle') {
            return e('ellipse', { key: el.id, cx: el.x + el.width/2, cy: el.y + el.height/2, rx: el.width/2, ry: el.height/2, fill: el.fillColor, stroke: el.strokeColor, strokeWidth: el.strokeWidth, onClick: () => onSelect(el.id) });
          }
        } else if (el.type === 'text') {
          return e('foreignObject', { key: el.id, x: el.x, y: el.y, width: el.width, height: el.height, onClick: () => onSelect(el.id) },
            e('div', { style: { fontSize: el.fontSize + 'px', color: el.fontColor, width: '100%', height: '100%' } }, el.text)
          );
        }
        return null;
      };
      
      return e('div', {
        ref: svgRef,
        className: 'canvas-container',
        style: { backgroundColor: bgColor, cursor: activeTool === 'pan' ? 'grab' : activeTool === 'draw' ? 'crosshair' : 'default' },
        onMouseDown: handleMouseDown,
        onMouseMove: handleMouseMove,
        onMouseUp: handleMouseUp,
        onMouseLeave: handleMouseUp
      },
        e('svg', { width: '100%', height: '100%', style: { transform: \`translate(\${localPanOffset.x}px, \${localPanOffset.y}px) scale(\${zoom})\` } },
          ...elements.map(renderElement),
          isDrawing && currentPath.length > 0 && e('path', {
            d: currentPath.map((p, i) => (i === 0 ? \`M \${p.x} \${p.y}\` : \`L \${p.x} \${p.y}\`)).join(' '),
            stroke: drawingOptions.strokeColor,
            strokeWidth: drawingOptions.strokeWidth,
            fill: 'none',
            strokeLinecap: 'round',
            strokeLinejoin: 'round'
          })
        )
      );
    });
    
    // ============================================
    // ä¸»åº”ç”¨ç»„ä»¶
    // ============================================
    
    function App() {
      const [language, setLanguage] = useState('zh');
      const [activeTool, setActiveTool] = useState('select');
      const [elements, setElements] = useState([]);
      const [history, setHistory] = useState([[]]);
      const [historyIndex, setHistoryIndex] = useState(0);
      const [panOffset, setPanOffset] = useState({ x: 400, y: 300 });
      const [zoom, setZoom] = useState(1);
      const [prompt, setPrompt] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [selectedIds, setSelectedIds] = useState([]);
      const [drawingOptions, setDrawingOptions] = useState({ strokeColor: '#111827', strokeWidth: 5 });
      const [canvasBgColor, setCanvasBgColor] = useState('#FFFFFF');
      const [uiTheme, setUiTheme] = useState({ color: '#FFFFFF', opacity: 0.9 });
      const [buttonTheme, setButtonTheme] = useState({ color: '#111827', opacity: 1 });
      const [generationMode, setGenerationMode] = useState('image');
      const [userEffects, setUserEffects] = useState(() => {
        try {
          const saved = localStorage.getItem('userEffects');
          return saved ? JSON.parse(saved) : [];
        } catch { return []; }
      });
      const [isSettingsOpen, setIsSettingsOpen] = useState(false);
      const [isLayerMinimized, setIsLayerMinimized] = useState(() => {
        const saved = localStorage.getItem('layerPanelMinimized');
        return saved === 'true';
      });
      const [isInspirationMinimized, setIsInspirationMinimized] = useState(() => {
        const saved = localStorage.getItem('inspirationPanelMinimized');
        return saved === 'true';
      });
      
      const t = useCallback((key, ...args) => {
        const keys = key.split('.');
        let result = translations[language];
        for (const k of keys) result = result?.[k];
        return typeof result === 'function' ? result(...args) : result || key;
      }, [language]);
      
      useEffect(() => {
        const root = document.documentElement;
        const hex = uiTheme.color.replace('#', '');
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        root.style.setProperty('--ui-bg-color', \`rgba(\${r}, \${g}, \${b}, \${uiTheme.opacity})\`);
        
        const btnHex = buttonTheme.color.replace('#', '');
        const btnR = parseInt(btnHex.substring(0, 2), 16);
        const btnG = parseInt(btnHex.substring(2, 4), 16);
        const btnB = parseInt(btnHex.substring(4, 6), 16);
        root.style.setProperty('--button-bg-color', \`rgba(\${btnR}, \${btnG}, \${btnB}, \${buttonTheme.opacity})\`);
      }, [uiTheme, buttonTheme]);
      
      useEffect(() => {
        localStorage.setItem('userEffects', JSON.stringify(userEffects));
      }, [userEffects]);
      
      useEffect(() => {
        localStorage.setItem('layerPanelMinimized', isLayerMinimized.toString());
      }, [isLayerMinimized]);
      
      useEffect(() => {
        localStorage.setItem('inspirationPanelMinimized', isInspirationMinimized.toString());
      }, [isInspirationMinimized]);
      
      const canUndo = historyIndex > 0;
      const canRedo = historyIndex < history.length - 1;
      
      const commitHistory = (newElements) => {
        const newHistory = history.slice(0, historyIndex + 1);
        newHistory.push(newElements);
        setHistory(newHistory);
        setHistoryIndex(newHistory.length - 1);
        setElements(newElements);
      };
      
      const handleUndo = () => {
        if (canUndo) {
          const newIndex = historyIndex - 1;
          setHistoryIndex(newIndex);
          setElements(history[newIndex]);
        }
      };
      
      const handleRedo = () => {
        if (canRedo) {
          const newIndex = historyIndex + 1;
          setHistoryIndex(newIndex);
          setElements(history[newIndex]);
        }
      };
      
      const handleUpload = async (file) => {
        const dataUrl = await fileToDataUrl(file);
        const img = new Image();
        img.onload = () => {
          const newEl = {
            id: generateId(),
            type: 'image',
            href: dataUrl,
            x: 100,
            y: 100,
            width: img.width,
            height: img.height,
            mimeType: file.type
          };
          commitHistory([...elements, newEl]);
        };
        img.src = dataUrl;
      };
      
      const handleGenerate = async () => {
        if (!prompt.trim()) return;
        
        setIsLoading(true);
        try {
          // æ”¶é›†é€‰ä¸­çš„å›¾åƒä½œä¸ºå‚è€ƒ
          const referenceImages = elements
            .filter(el => selectedIds.includes(el.id) && el.type === 'image')
            .map(el => el.href)
            .filter(Boolean);
          
          // è°ƒç”¨APIç”Ÿæˆå›¾åƒ
          const imageUrl = await generateImage(prompt, referenceImages);
          
          // åˆ›å»ºæ–°çš„å›¾åƒå…ƒç´ 
          const img = new Image();
          img.onload = () => {
            const newEl = {
              id: generateId(),
              type: 'image',
              href: imageUrl,
              x: panOffset.x / zoom + 100,
              y: panOffset.y / zoom + 100,
              width: img.width,
              height: img.height,
              name: prompt.slice(0, 30) + (prompt.length > 30 ? '...' : '')
            };
            commitHistory([...elements, newEl]);
            setPrompt('');
          };
          img.onerror = () => {
            console.error('ç”Ÿæˆçš„å›¾åƒåŠ è½½å¤±è´¥');
            alert('ç”Ÿæˆçš„å›¾åƒåŠ è½½å¤±è´¥');
          };
          img.src = imageUrl;
        } catch (error) {
          console.error('ç”Ÿæˆå›¾åƒå¤±è´¥:', error);
          if (error.message.includes('API Key')) {
            alert('âš ï¸ è¯·é…ç½® Gemini API Key\\n\\nåœ¨Gemini Canvasä¸­ï¼ŒAPI Keyä¼šè‡ªåŠ¨æ³¨å…¥ã€‚\\nåœ¨æœ¬åœ°è¿è¡Œæ—¶ï¼Œè¯·åœ¨ä»£ç ä¸­è®¾ç½® API_KEY å˜é‡ã€‚');
          } else {
            alert(\`ç”Ÿæˆå›¾åƒå¤±è´¥ï¼š\${error.message}\\n\\nè¯·æŸ¥çœ‹æ§åˆ¶å°äº†è§£è¯¦ç»†ä¿¡æ¯ã€‚\`);
          }
        } finally {
          setIsLoading(false);
        }
      };
      
      const handleToggleVisible = (id) => {
        const newElements = elements.map(el => el.id === id ? { ...el, isVisible: el.isVisible === false ? true : false } : el);
        commitHistory(newElements);
      };
      
      const handleToggleLock = (id) => {
        const newElements = elements.map(el => el.id === id ? { ...el, isLocked: !el.isLocked } : el);
        commitHistory(newElements);
      };
      
      const handleSelect = (id) => {
        setSelectedIds([id]);
      };
      
      return e('div', { className: 'w-full h-full relative' },
        e(Canvas, {
          elements,
          bgColor: canvasBgColor,
          panOffset,
          zoom,
          activeTool,
          drawingOptions,
          onElementsChange: commitHistory,
          selectedIds,
          onSelect: handleSelect
        }),
        
        e(Toolbar, {
          activeTool,
          setActiveTool,
          onUpload: handleUpload,
          onUndo: handleUndo,
          onRedo: handleRedo,
          canUndo,
          canRedo,
          onSettings: () => setIsSettingsOpen(true),
          drawingOptions,
          setDrawingOptions,
          t,
          isLayerExpanded: !isLayerMinimized
        }),
        
        !isLayerMinimized && e(LayerPanel, {
          elements,
          selectedIds,
          onSelect: handleSelect,
          onToggleVisible: handleToggleVisible,
          onToggleLock: handleToggleLock,
          onReorder: () => {},
          t,
          isMinimized: isLayerMinimized,
          onToggle: () => setIsLayerMinimized(!isLayerMinimized)
        }),
        
        isLayerMinimized && e('button', {
          onClick: () => setIsLayerMinimized(false),
          className: 'fixed left-4 top-4 z-20 p-3 bg-white border border-gray-200 rounded-xl shadow-md hover:bg-gray-50',
          title: t('layers.title')
        }, e(Icon, { name: 'eye' })),
        
        !isInspirationMinimized && e(InspirationPanel, {
          t,
          isMinimized: isInspirationMinimized,
          onToggle: () => setIsInspirationMinimized(!isInspirationMinimized)
        }),
        
        isInspirationMinimized && e('button', {
          onClick: () => setIsInspirationMinimized(false),
          className: 'fixed right-4 top-4 z-20 p-3 bg-white border border-gray-200 rounded-xl shadow-md hover:bg-gray-50',
          title: t('inspiration.title')
        }, e(Icon, { name: 'lightbulb' })),
        
        e(PromptBar, {
          prompt,
          setPrompt,
          onGenerate: handleGenerate,
          isLoading,
          t,
          mode: generationMode,
          setMode: setGenerationMode,
          userEffects,
          onAddEffect: (eff) => setUserEffects([...userEffects, eff]),
          onDeleteEffect: (id) => setUserEffects(userEffects.filter(e => e.id !== id)),
          selectedCount: selectedIds.filter(id => elements.find(el => el.id === id && el.type === 'image')).length
        }),
        
        e(SettingsPanel, {
          isOpen: isSettingsOpen,
          onClose: () => setIsSettingsOpen(false),
          language,
          setLanguage,
          canvasBgColor,
          setCanvasBgColor,
          uiTheme,
          setUiTheme,
          buttonTheme,
          setButtonTheme,
          t
        })
      );
    }
    
    // ============================================
    // æŒ‚è½½åº”ç”¨
    // ============================================
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(e(App));
    
    console.log('%cğŸ¨ Making - å®Œæ•´åŠŸèƒ½ç‰ˆå·²å¯åŠ¨ï¼', 'color: #3b82f6; font-size: 16px; font-weight: bold');
    console.log('%câœ… å·²åŒ…å«åŠŸèƒ½ï¼š', 'color: #10b981; font-weight: bold');
    console.log('  â€¢ å®Œæ•´å·¥å…·æ ï¼ˆé€‰æ‹©ã€å¹³ç§»ã€ç»˜å›¾ã€å½¢çŠ¶ã€æ–‡æœ¬ç­‰ï¼‰');
    console.log('  â€¢ çµæ„Ÿåº“ç³»ç»Ÿï¼ˆè§’è‰²/åœºæ™¯/é“å…·åˆ†ç±»ï¼Œå¸¦ä¼ é€é—¨åŠ¨ç”»ï¼‰');
    console.log('  â€¢ å›¾å±‚é¢æ¿ï¼ˆæ˜¾ç¤º/éšè—ã€é”å®šï¼Œå¸¦ä¼ é€é—¨åŠ¨ç”»ï¼‰');
    console.log('  â€¢ ç”»å¸ƒç»˜å›¾ï¼ˆè·¯å¾„ç»˜åˆ¶ã€å›¾ç‰‡ä¸Šä¼ ï¼‰');
    console.log('  â€¢ æ’¤é”€/é‡åšå†å²è®°å½•');
    console.log('  â€¢ AIæç¤ºè¯è¾“å…¥ï¼ˆå›¾ç‰‡/è§†é¢‘æ¨¡å¼ï¼Œå¿«æ·æ•ˆæœï¼‰');
    console.log('  â€¢ è®¾ç½®é¢æ¿ï¼ˆå¤šè¯­è¨€ã€ä¸»é¢˜ã€ç”»å¸ƒèƒŒæ™¯ï¼‰');
    console.log('  â€¢ IndexedDBæœ¬åœ°å­˜å‚¨');
    console.log('  â€¢ ç±»LovartåŠ¨ç”»æ•ˆæœ');
    console.log('  â€¢ ğŸ”¥ Gemini API å›¾åƒç”Ÿæˆï¼ˆæ”¯æŒå‚è€ƒå›¾åƒï¼‰');
    console.log('%câš ï¸  ä½¿ç”¨è¯´æ˜ï¼š', 'color: #f59e0b; font-weight: bold');
    console.log('  â€¢ åœ¨Gemini Canvasä¸­è¿è¡Œï¼šAPI Keyä¼šè‡ªåŠ¨æ³¨å…¥');
    console.log('  â€¢ åœ¨æœ¬åœ°è¿è¡Œï¼šéœ€åœ¨ä»£ç ä¸­è®¾ç½® API_KEY å˜é‡');
    console.log('  â€¢ é€‰ä¸­ç”»å¸ƒä¸Šçš„å›¾åƒåç”Ÿæˆï¼Œå¯ä½œä¸ºå‚è€ƒå›¾åƒ');
    console.log('  â€¢ å›¾åƒç”Ÿæˆå¤±è´¥ä¼šè‡ªåŠ¨é‡è¯•3æ¬¡');
  </script>
</body>
</html>

